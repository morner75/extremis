bevfd.kernel<- function(Y, Xt, X, tau = 0.95, smoothing = 'lscv', 
                        grid = seq(0.01, 0.99, length = 2^8),
                        raw = TRUE, target = "pdf")
  UseMethod("bevfd.kernel")


bevfd.kernel.default<-function(Y, X, Xt, tau = 0.95, smoothing = "lscv",
                          grid = seq(0.01, 0.99, length = 2^8), 
                          raw = TRUE, target = "pdf"){
    ## Basic input validation
    if (tau >= 1)
        stop('tau must be smaller than 1')
    if(b <= 0)
        stop('b must be positive')
    if(nu <= 0)
        stop('nu must be positive')
    if (centering < 0)
        stop('centering must be positive')
    if (dim(Y)[2] > 2)
        stop('this function only applies to bivariate extremes')
    
    ## Convert data to common margins, if raw == TRUE
    if (raw == TRUE) {
        FX <- ecdf(Y[, 1])
        FY <- ecdf(Y[, 2])
        x <- -1 / log(n / (n + 1) * FX(Y[, 1]))
        y <- -1 / log(n / (n + 1) * FY(Y[, 2]))
    }
    if (raw == FALSE) {
        x <- Y[, 1]
        y <- Y[, 2]
    }
    n <- dim(Y)[1]
    ## Compute angles and threshold radius
    w <- x / (x + y)
    u <- quantile(x + y, tau)     
    w <- w[which(x + y > u)]
    if (is.numeric(smoothing) == TRUE){
        b <- smoothing[1]
        nu <- smoothing[2]
        centering <- smoothing[3] 
        nm <- metric.lp(X, Xt)[1, ][1:length(w)]
        p <- function(nm)
            2 * dnorm(nm/b) / b * (nm > 0) / sum(2 * dnorm(nm/b) / b * (nm > 0))
        smooth <-function(W)
            sum(p(nm)*
                dbeta(W, (nu * w * ((0.5) / 
                                    (sum(p(nm) * w)))) + centering,
                (nu * (1 - (w * (0.5 / (sum(p(nm) * w)))))) + centering))
        
        h <- sapply(grid, smooth)
    } else if (smoothing == 'lscv') {
        nobreaks <- 10 ## CHANGE LATER
        k <- length(w)
        folds <- cut(seq(1, k), breaks = nobreaks, labels = FALSE)
        kf <- sapply(1:k, FUN = function(j) {
            index <- which(folds == j, arr.ind = TRUE)
            test <- w[index]
            nm <- metric.lp(X, Xt)[1, ][1:length(w[index])]
            p <- function(nm)
                2 * dnorm(nm/b)/b * (nm > 0)/sum(2 * dnorm(nm/b)/b * (nm > 0))
            smooth <-function(W)
                sum(p(nm) * dbeta(W, nu * ((.5)/(sum(p(nm) * w[index]))) *
                                     w[index] + centering, 
                                  nu * (1 - (w[index] * ((.5) / (sum(p(nm) * w[index]))))) + centering))
            smoothing <- optim(smooth, par = c(1,1,1))$par          
            return(smooth)
        })
        h <- sapply(w[-index],smooth)
    }
  
  if (target == "pdf") {
    smooth <-function(W)
        sum(p(nm)*dbeta(W,(nu*w*((0.5)/
  (sum(p(nm)*w))))+centering,(nu*(1-(w*(0.5/(sum(p(nm)* w))))))+centering))
    h <- sapply(grid, smooth)}
  if (target == "cdf") {
    smooth <-function(W)sum(p(nm)*pbeta(W,(nu*w*((0.5)/
   (sum(p(nm)*w))))+centering,(nu*(1-(w*(0.5/(sum(p(nm)* w))))))+centering))
    h <- sapply(grid, smooth)}
  if (target == "Pickands") {
    smooth <- function(W) {
      ptilde <- numeric(k)
      integrand <-function(W)sum(p(nm)*pbeta(W,(nu*w*((0.5)/
                                                        (sum(p(nm)*w))))+centering,(nu*(1-(w*(0.5/(sum(p(nm)* w))))))+centering))
      for(i in 1:k) 
        ptilde[i] <- p[i] * as.numeric(integrate(integrand, 0, W)[1])            
      1 - W + 2 * sum(ptilde)
    }
    smooth <- Vectorize(smooth)
    h <- sapply(grid, smooth)
  }
  
  ## Organize and return outputs    
  outputs <- list(h = h, w = w,Y = Y, X = X, Xt = Xt, b=b, nu = nu,
                  centering=centering, grid = grid,target = target)
  class(outputs) <- "bevfd.kernel"
  return(outputs)
}


plot.bevfd.kernel<-  function(fit, xlab = "w", ...) {
  grid <- fit$grid
  trajhat <- fit$h
  target <- fit$target
  
  if (target == "pdf" | target == "cdf") {
    frame <- data.frame(grid = grid, trajhat = trajhat)
    gg <- ggplot(data = frame, aes(x = grid, y = trajhat)) +
      geom_line(aes(x = grid, y = trajhat), size = 1.1, col = "blue") +
      theme_classic() +
      theme(axis.text = element_text(size = 10),
            axis.title = element_text(size = 10))
    gg <- gg  + geom_rug(data = data.frame(w = fit$w), aes(x = w, y = 0),
                         alpha = 0.5, sides = 'b')
    if (target == "pdf")
      gg <- gg + labs(y = "Cross Section of Angular Manifold", x = "w", 
                      size = 1.1)        
    if (target == "cdf")
      gg <- gg + labs(y = "Cross Section of Angular Manifold", x = "w", 
                      size = 1.1)  
    plot(gg)
    
  } else if (target == "Pickands") {
    frame <- data.frame(grid = c(0, fit$grid, 1), trajhat = c(1, fit$h, 1))
    ggplot(data = frame, aes(x = grid, y = trajhat)) +
      geom_line(aes(x = grid, y = trajhat), size = 1.1, col = "blue") +
      theme_classic() +
      theme(axis.text = element_text(size = 10),
            axis.title = element_text(size = 10)) +            
      coord_fixed(xlim = c(0, 1), ylim = c(0.5, 1)) +
      labs(y = "Pickands Dependence Function", x = "w", size = 1.1)
  }
  
}
#ggsave("plot.bevfd.kernel.pdf")
